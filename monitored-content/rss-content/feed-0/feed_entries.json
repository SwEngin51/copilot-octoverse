[
  {
    "id": "https://github.blog/changelog/2025-10-29-github-mcp-server-now-comes-with-server-instructions-better-tools-and-more",
    "title": "GitHub MCP Server now comes with server instructions, better tools, and more",
    "link": "https://github.blog/changelog/2025-10-29-github-mcp-server-now-comes-with-server-instructions-better-tools-and-more",
    "published": "Wed, 29 Oct 2025 09:07:43 +0000",
    "content": "The GitHub MCP Server now comes with server instructions that unlock new and better ways in which it can be used by models. We\u2019ve also continued to decrease the footprint of the GitHub MCP Server by consolidating more tools into fewer, more powerful tools. And now, configuring the GitHub MCP Server to your needs just got way easier! Visit the GitHub MCP Server repository to learn more. Server instructions and multitool workflows Server instructions are a feature of the Model Context Protocol specification which acts like a system prompt that guides the model in effectively using an MCP server. They\u2019re especially useful for things like respecting tool interdependence (\u201calways use tool A before tool B\u201d), following multitool workflows (\u201cwhen asked to review a pull request, always start off with tool A, then use tool B, and finally tool C\u201d) or giving general guidance for commonalities that underlie most tools (\u201calways use pagination when available\u201d). With the addition of server instructions to the GitHub MCP Server, we\u2019ve unlocked new possibilities. Models will now be much better at following precise workflows for tasks like reviewing pull requests and managing issues or discussions. They will also generally use tools more effectively across the board. Now that server instructions are part of the GitHub MCP Server, we will work on continuously improving them as our MCP server evolves! As always, we are listening closely to feedback from our users on how we can tweak instructions to best serve developer needs. Consolidating tools into more powerful multifunctional tools: pull requests, issues, sub-issues We\u2019re continuing our work to make the GitHub MCP Server simpler and more performant by merging more related tools into unified, multifunctional ones. Just like before, each consolidated tool supports multiple operations through a single method parameter, making configurations leaner, AI reasoning clearer, and performance faster. Similar to the consolidation of the pull request tools in the previous release, the following pull request review tools have now been consolidated into a single, powerful pullrequestreview_write tool: createandsubmitpullrequest_review creatependingpullrequestreview submitpendingpullrequestreview deletependingpullrequestreview The new tool has a method parameter to perform these tasks: create submit_pending delete_pending The following issue tools have been consolidated into a single, powerful issue_read tool: get_issue getissuecomments listlabels (with issuenumber) listsubissues The new tool has a method parameter to perform these operations: get get_comments get_labels getsubissues Furthermore, the following issue tools are consolidated into a single issue_write tool: create_issue update_issue The new tool has a method parameter for these operations: create update Finally, the following sub-issue tools have been consolidated into a single subissuewrite tool: addsubissue removesubissue reprioritizesubissue The new tool has a method parameter to perform these operations: add reprioritize remove If you notice that a commonly used tool is missing, it\u2019s likely been consolidated into a new multifunctional tool or moved out of the default configuration. Easier server configuration with the new default keyword Previously, toolsets could only be configured by typing them out one by one when configuring the MCP server. We\u2019ve made this process easier by introducing the default keyword. You can use this keyword when configuring your server to refer to the default toolset. Now, adding a toolset like codesecurity to your default MCP configuration is as simple as X-MCP-Toolsets:\"default,codesecurity\" for the remote MCP server or --toolsets default,code_security for the local MCP server. Note that just as before, the default toolset will contain the following toolsets: context \u2013 Current user and GitHub context repos \u2013 Repository operations issues \u2013 Issue tracking pull_requests \u2013 Pull request workflows users \u2013 User information The post GitHub MCP Server now comes with server instructions, better tools, and more appeared first on The GitHub Blog.",
    "content_hash": "ef83fedb2d7d329ea40b49e9936136fa83f96f4949e0bca0c03c4dec0d8d6137",
    "feed_index": 0,
    "detected_date": "2025-11-01T09:07:07.105877"
  },
  {
    "id": "https://github.blog/changelog/2025-10-28-auto-draft",
    "title": "GitHub Copilot in Visual Studio Code gets upgraded",
    "link": "https://github.blog/changelog/2025-10-28-github-copilot-in-visual-studio-code-gets-upgraded",
    "published": "Tue, 28 Oct 2025 15:30:02 +0000",
    "content": "The following items released to VS Code Insiders and were announced at GitHub Universe 2025. Highlights OpenAI Codex integration: Access OpenAI Codex in VS Code Insiders with a Copilot Pro+ subscription. Agent Sessions view: Manage local and cloud agent sessions from a unified interface. Context-isolated sub-agents: Subagents let you delegate focused tasks (e.g., running TDD workflows, conducting research) that can be solved independently from your main chat for context-optimized token usage. Plan Mode: Create, refine, and execute step-by-step implementation plans. Plan Mode analyzes your codebase, generates detailed execution plans, and validates that requirements are covered before starting to code. Explore all the new features in the full release notes. Happy coding! Note: The Insiders build installs side-by-side with the monthly Stable build, and you can freely work with either, on the same machine. The Insiders build is the same one the VS Code development team uses daily, and we really appreciate people trying out new features and providing feedback. Refresh your Insiders build by opening VS Code Insiders and selecting Help \u2192 Check for Updates and then restarting when prompted. The post GitHub Copilot in Visual Studio Code gets upgraded appeared first on The GitHub Blog.",
    "content_hash": "182d4373513f531ef50bbd71ef3d132bde98048fb93913eb81bde1e0824658b7",
    "feed_index": 0,
    "detected_date": "2025-11-01T09:07:07.105883"
  },
  {
    "id": "https://github.blog/changelog/2025-10-27-a-mission-control-to-assign-steer-and-track-copilot-coding-agent-tasks",
    "title": "A mission control to assign, steer, and track Copilot coding agent tasks",
    "link": "https://github.blog/changelog/2025-10-28-a-mission-control-to-assign-steer-and-track-copilot-coding-agent-tasks",
    "published": "Tue, 28 Oct 2025 15:29:08 +0000",
    "content": "We\u2019ve redesigned how you manage your Copilot coding agent tasks on github.com. Instead of jumping between pages to track progress, monitor changes, and manage tasks, everything you need now lives in one streamlined, centralized view. Get a full picture of Copilot\u2019s activity in a single view. View session logs right next to the Overview and Files changed tabs, letting you check all the relevant information without ever leaving the page. See the rationale behind Copilot\u2019s commits as they happen, right in context. Real-time steering Copilot is more responsive than ever. With real-time steering, you can guide Copilot as it\u2019s working. Provide input while a session runs, and Copilot will adapt as soon as its current tool call completes. It\u2019s also easier to give feedback, with no more jumping to pull request comments to @copilot. Simply steer through the chat input or add a comment directly in the Files changed view. Centralizing your task management Switch between tasks effortlessly with the new task view. See task status at a glance and jump in when Copilot needs your input. Quick links on the task make it easy to navigate straight to the pull request. More creation flexibility In addition to the existing options in the agents panel and at github.com/copilot/agents, you can now create Copilot coding agent tasks directly on github.com, from github.com/copilot (by typing /task in chat), and from the GitHub Mobile agents task page. No matter where you start a task, you can choose a custom agent to further customize Copilot\u2019s output. Continue where you prefer working Whether you\u2019d like to build on Copilot\u2019s work or take full control, open your session in Codespaces, VS Code Insiders, or the GitHub CLI. This feature is available to all users who have access to Copilot coding agent. Collaborating with Copilot on your task will require write access to the repository. To access your session in VSCode Insiders, ensure that you have the latest version of VScode Insiders installed alongside the GitHub Copilot Chat and GitHub Pull Requests extensions. Join the discussion within GitHub Community. The post A mission control to assign, steer, and track Copilot coding agent tasks appeared first on The GitHub Blog.",
    "content_hash": "bed853095dd19bcd1976d98f9e1846b58f758f4ff2285badc459f443d076e7e7",
    "feed_index": 0,
    "detected_date": "2025-11-01T09:07:07.105886"
  },
  {
    "id": "https://github.blog/changelog/2025-10-24-new-public-preview-features-in-copilot-code-review-ai-reviews-that-see-the-full-picture",
    "title": "New public preview features in Copilot code review: AI reviews that see the full picture",
    "link": "https://github.blog/changelog/2025-10-28-new-public-preview-features-in-copilot-code-review-ai-reviews-that-see-the-full-picture",
    "published": "Tue, 28 Oct 2025 15:27:44 +0000",
    "content": "Copilot code review (CCR) now blends LLM detections and tool calling with deterministic tools like ESLint and CodeQL, delivering smarter reviews and a seamless handoff to the Copilot coding agent for fixes. Rich context with tool calling \ud83e\uddf0 CCR now leverages agentic tool calling to actively gather full project context, including code, directory structure, and references. This enables CCR to understand how your changes fit within the broader project architecture. \ud83d\udca1 Why it matters: Feedback is specific, accurate, and with less noise, helping you ship cleaner code faster. New deterministic detections with CodeQL and ESLint\ud83d\udd75\ufe0f\u200d\u2640\ufe0f CCR now integrates CodeQL and leading linters (starting with ESLint) to combine semantic analysis and classic rule-based checks. This fusion of LLM intelligence and deterministic precision delivers high-signal, consistent findings for security and quality. \ud83d\udca1 Why it matters: Developers can trust that critical issues, from security vulnerabilities to maintainability problems, are reliably caught and clearly explained. Editor\u2019s note (October 31, 2025): Updated the why it matters description. Seamless handoff to Copilot coding agent \ud83e\udd1d You can now hand off suggested changes directly to the Copilot coding agent. Mention @copilot in your pull request, and CCR will automatically apply the suggested fixes in a stacked pull request, ready for you to review and merge. \ud83d\udca1 Why it matters: Less manual cleanup and fewer review cycles. So you stay focused on higher-value engineering work. [Demo video: Use of implement suggestion button from CCR comment] Customizable workflows and editor availability \ud83d\udee0\ufe0f With customizable workflows and multi-editor support already generally available, CCR now fits seamlessly into every step of your development process, from writing code to reviewing and merging. Teams can define their own review standards and tone through instructions.md or copilot-instructions.md files, shaping what CCR prioritizes (e.g., test coverage, performance, or readability). CCR is available in VS Code, Visual Studio, JetBrains, Xcode, and on github.com, ensuring consistent feedback wherever you work. \ud83d\udca1 Why it matters: CCR adapts to your team\u2019s standards and meets you where you work. Getting started \ud83d\ude80 Tool calling and deterministic detections are in public preview, enabled by default for Copilot Pro and Copilot Pro Plus users. Copilot Business and Copilot Enterprise users can opt in using the Copilot code review policies. Join the discussion within GitHub Community. Disclaimer: The UI for features in public preview is subject to change. The post New public preview features in Copilot code review: AI reviews that see the full picture appeared first on The GitHub Blog.",
    "content_hash": "7dfef351aad06374b082c472105938c6b017b9d32585c4bfded0de19495daaed",
    "feed_index": 0,
    "detected_date": "2025-11-01T09:07:07.105887"
  },
  {
    "id": "https://github.blog/changelog/2025-10-23-work-with-copilot-coding-agent-in-slack",
    "title": "Work with Copilot coding agent in Slack",
    "link": "https://github.blog/changelog/2025-10-28-work-with-copilot-coding-agent-in-slack",
    "published": "Tue, 28 Oct 2025 15:26:45 +0000",
    "content": "The GitHub app for Slack now works with GitHub Copilot coding agent, letting you generate pull requests directly from your Slack conversations. Editor\u2019s note (October 28, 2025): Removed the reference to a gradual roll out now that the feature is widely available. Mention @GitHub in any Slack thread with a prompt, and Copilot coding agent will get to work in the background, then reply when the pull request is ready for review. Copilot coding agent is our asynchronous and autonomous developer agent that\u2019s great for offloading tasks like bug fixes, incremental new features, test coverage, and refactors. It frees you up to focus on more complex problems. Try it out Make sure Copilot coding agent is enabled for your GitHub account. Copilot coding agent is available with all paid Copilot plans. If you\u2019re a Copilot Business or Enterprise subscriber, an admin must enable the policy. Install or upgrade the GitHub app in your Slack workspace. Mention @GitHub in a Slack thread with a prompt like \u201cFix missing tooltips on navigation icons\u201d to start Copilot coding agent and follow its progress directly in the thread. Link your GitHub account. The new Copilot coding agent functionality is optional, and requires new permissions. If you prefer not to upgrade, you can continue using the GitHub app as before for notifications, issue triage, and pull request management. The GitHub app for Slack joins the GitHub app for Microsoft Teams, which is now generally available. Learn more about integrating Copilot coding agent with Slack or Teams, and join the discussion in the GitHub Community. The post Work with Copilot coding agent in Slack appeared first on The GitHub Blog.",
    "content_hash": "8b9b6fa2139b0c3defc98326a0b405d02c314c0fb40fe86f75e954929adb08d0",
    "feed_index": 0,
    "detected_date": "2025-11-01T09:07:07.105889"
  },
  {
    "id": "https://github.blog/changelog/2025-10-24-github-copilot-for-linear-available-in-public-preview",
    "title": "GitHub Copilot for Linear available in public preview",
    "link": "https://github.blog/changelog/2025-10-28-github-copilot-for-linear-available-in-public-preview",
    "published": "Tue, 28 Oct 2025 15:25:36 +0000",
    "content": "You can now assign issues in Linear to Copilot coding agent, our asynchronous, autonomous background agent. When you assign a Linear issue to Copilot, it will: Analyze the issue contents and open a draft pull request. Work independently in its own ephemeral development environment, powered by GitHub Actions. Within this environment, Copilot can explore your code, make changes, run automated tests and linters, and more. Stream progress updates back to your Linear activity timeline. Request a pull request review from you when work is completed. Key benefits Automate repetitive tasks like bug fixes, refactors, and documentation updates. Reduce manual steps and context switching between Linear and GitHub. Follow your existing review and approval rules for every pull request Copilot creates. Get started Install the GitHub Copilot coding agent for Linear app from the GitHub Marketplace. You\u2019ll need organization owner permissions in GitHub and workspace admin privileges in Linear. Review our documentation to learn more about the integration and Copilot coding agent. We welcome your feedback. Feel free to share your thoughts in the community discussion. The post GitHub Copilot for Linear available in public preview appeared first on The GitHub Blog.",
    "content_hash": "a2b6df52980be849ec6eec6fbba2fb8ee61865bf7f8a67a20e04a7d21b7828bd",
    "feed_index": 0,
    "detected_date": "2025-11-01T09:07:07.105890"
  },
  {
    "id": "https://github.blog/changelog/2025-10-27-enterprise-ai-controls-the-agent-control-plane-are-in-public-preview",
    "title": "Enterprise AI controls & the agent control plane are in public preview",
    "link": "https://github.blog/changelog/2025-10-28-enterprise-ai-controls-the-agent-control-plane-are-in-public-preview",
    "published": "Tue, 28 Oct 2025 15:24:07 +0000",
    "content": "We\u2019re introducing a new enterprise-level experience focused on administrative functions for AI systems, available today to all GitHub Enterprise Cloud customers using Copilot. This is your agent control plane, a suite of enterprise governance features designed to give organizations deeper control over how agents operate across their environments. Enterprise administrators are often charged with enabling AI capabilities for their teams while keeping their businesses safe. To do this job well, we\u2019re improving awareness of agentic activity, increasing auditability, and launching complimentary capabilities that make custom agents enterprise-ready. Answering questions about what agents are doing in your enterprise has never been easier. AI controls are in the agent control plane Let\u2019s start with some basic features of the agent control plane: One consolidated view and top-level navigation for all administrative tasks related to AI systems in GitHub. Administrators can manage their agentic fleet. The few agents now, and the thousands in the future, are operationalized here for your enterprise. The permanent home for enterprise-level policies and configuration of Copilot and AI-related systems. Enterprise-ready custom agents With the launch of custom agents, enterprises will want to determine a path toward standardized adoption: Configure one organization to host the enterprise standard for custom agents. Use a 1-click push rule to protect the static file path for custom agents (i.e., .github/agents/*.md) across your enterprise from edits. Adjust push rules to fit your organizational design and experimentation tolerances. Select Enterprise-defined custom agents when assigning Copilot coding agent to any issue. Agent session activity Develop awareness of agent activity in the enterprise: See enterprise-wide agent sessions for the last 24 hours. Filter on agent type and the task state (e.g., completed, cancelled, in progress). Navigate directly to the target repository, if you have authorization to do so. Agentic audit logs What are your agents really doing? The audit logs have the answer: New fields for agent activity (e.g., pull_request.create executed by Copilot): Identify an actorisagent. Show user and user_id to identify who the agent is acting on behalf of. A new event for agent_session.task shows which sessions have started, finished, or failed to complete. You can quickly navigate to agent-related audit logs from the AI controls tab. AI administration fine-grained permissions (FGPs) are coming soon! AI and Copilot administration is a job done by a team of people at most companies. And that team is not always responsible for running all of GitHub Enterprise. Later this week you can: Utilize a new FGP that grants access to the AI controls view. Build an enterprise custom role to decentralize administration of AI systems without granting broad enterprise ownership. Assign the enterprise custom role to an enterprise team to manage at scale. MCP enterprise allowlist Set enterprise-wide MCP allowlist via MCP registry URL to govern MCP connections in VS Code Insiders. Configure MCP policies from the AI controls experience. Omit local servers from registry to prevent the use of untrusted tools. Support for VS Code and other IDEs in general availability will be coming soon! To learn more, see our documentation on AI controls and the agent control plane. Join the discussion within GitHub Community. The post Enterprise AI controls & the agent control plane are in public preview appeared first on The GitHub Blog.",
    "content_hash": "19aca41588f2063698d353af26cd666db913bd8202ba252ef6b7d3ac8d1e8c23",
    "feed_index": 0,
    "detected_date": "2025-11-01T09:07:07.105891"
  },
  {
    "id": "https://github.blog/changelog/2025-10-22-copilot-usage-metrics-dashboard-and-api-in-public-preview",
    "title": "Copilot usage metrics dashboard and API in public preview",
    "link": "https://github.blog/changelog/2025-10-28-copilot-usage-metrics-dashboard-and-api-in-public-preview",
    "published": "Tue, 28 Oct 2025 15:23:43 +0000",
    "content": "The Copilot usage metrics dashboard and corresponding API are available in public preview for GitHub Enterprise. The AI era of software development isn\u2019t about are teams using AI, but rather how well are they using it? The GitHub Copilot usage metrics dashboard and API, now in public preview for GitHub Enterprise customers using Copilot, helps you answer that question with data. You can now see how Copilot adoption and engagement in the IDE varies across both your enterprise and your users to understand who\u2019s using it, where, and how. What\u2019s included in the public preview The Copilot usage metrics dashboard gives enterprise administrators and billing managers direct visibility into Copilot usage and adoption under the Insights tab. T he dashboard provides an aggregated enterprise view, while the NDJSON download or API offer user-level granularity for deeper analysis. In this public preview, you\u2019ll find metrics including: Daily and weekly active users across GitHub Copilot IDE modes, including agent mode. Agent adoption across your user base. Lines of code added and deleted across all IDE modes. Language and model usage patterns across IDEs. These metrics help you understand: Overall usage and adoption: Review indicators like weekly usage provide a broad view of Copilot adoption across your enterprise. Specific model, feature, and language usage: See which AI models and programming languages are most utilized by your teams, highlighting areas for even greater value. Agent adoption percentage: Track how many developers are using Copilot for advanced tasks like refactoring, debugging, and complex problem solving. High agent adoption signals a shift toward truly transformative coding. Together, these are foundational metrics showing who\u2019s adopting Copilot, how consistently, and what that usage looks like across your enterprise. How to enable Copilot usage metrics in your enterprise By default, Copilot usage metrics are disabled unless your enterprise participated in the private preview, in which case they remain enabled. Enterprise admins can enable them as follows: Navigate to your AI Controls tab on github.com. Select Copilot in the left sidebar. Scroll down to the \u201cMetrics\u201d section where you\u2019ll see Copilot usage metrics. Change the Copilot usage metrics policy setting to Enabled. This will enable the Copilot usage metrics dashboard and API for your enterprise, allowing enterprise administrators and billing managers to view usage and adoption data. Once enabled, you can access the Copilot usage metrics dashboard directly from the Insights tab at the enterprise level or through the Enterprise and user-level API. Learn more View the Copilot usage metrics dashboard documentation. Explore the Copilot usage metrics API. Join the discussion to share your feedback and ask questions. Editor\u2019s note (October 29, 2025): Updated the Community discussion link to go to the correct discussion page. Disclaimer: The UI for features in public preview is subject to change. The post Copilot usage metrics dashboard and API in public preview appeared first on The GitHub Blog.",
    "content_hash": "d4dcf41143dad61e6ea7069c3af07e246ec99f7ba9467303e98d22352a9da53b",
    "feed_index": 0,
    "detected_date": "2025-11-01T09:07:07.105892"
  },
  {
    "id": "https://github.blog/changelog/2025-10-20-ask-copilot-coding-agent-to-make-changes-in-any-pull-request-with-copilot",
    "title": "Ask Copilot coding agent to make changes in any pull request with @copilot",
    "link": "https://github.blog/changelog/2025-10-28-ask-copilot-coding-agent-to-make-changes-in-any-pull-request-with-copilot",
    "published": "Tue, 28 Oct 2025 15:20:57 +0000",
    "content": "As well as open new pull requests from scratch, Copilot can now help you make changes to an existing pull request created by a human\u2014just mention @copilot in a comment. Copilot coding agent is our asynchronous, autonomous background agent. Delegate a task to Copilot, and it works in the background, then requests a review from you. When you mention @copilot in a comment, Copilot will open a new pull request on top of your existing pull request, using the existing pull request\u2019s branch as its base branch. Once it has finished work on the changes you requested, it requests your review on the new pull request. You maintain control of your original pull request. Until you accept Copilot\u2019s proposed changes by merging the new pull request into your branch, your pull request will remain untouched. Pull requests that merge into another pull request\u2019s branch are now clearly marked to make them easier to spot. Copilot coding agent is available to Copilot Pro, Copilot Pro+, Copilot Business, and Copilot Enterprise subscribers. If you\u2019re a Copilot Business or Copilot Enterprise subscriber, an administrator will have to enable Copilot coding agent from the \u201cPolicies\u201d page before you can use it. To learn more about Copilot coding agent, head to our documentation on coding agent. The post Ask Copilot coding agent to make changes in any pull request with @copilot appeared first on The GitHub Blog.",
    "content_hash": "4c3a1becde1fc4eaaabbea9f9ebc087af63c140ca794ac35f8744ed597a51713",
    "feed_index": 0,
    "detected_date": "2025-11-01T09:07:07.105893"
  },
  {
    "id": "https://github.blog/changelog/2025-10-21-copilot-coding-agent-now-supports-self-hosted-runners",
    "title": "Copilot coding agent now supports self-hosted runners",
    "link": "https://github.blog/changelog/2025-10-28-copilot-coding-agent-now-supports-self-hosted-runners",
    "published": "Tue, 28 Oct 2025 15:20:53 +0000",
    "content": "You can now configure Copilot coding agents\u2019s development environment to run in your own infrastructure using self-hosted GitHub Actions runners managed by Actions Runner Controller (ARC). With this setup, you can give Copilot access to internal resources (e.g. packages) not available on the public internet. Copilot coding agent is our asynchronous, autonomous background agent. Delegate a task to Copilot and it opens a draft pull request, makes changes in the background, and then requests a review from you. Copilot works in its own ephemeral development environment, powered by GitHub Actions, where it can run the repository\u2019s build process, automated tests, and more. ARC scale sets are supported as a runs-on: target for the copilot-setup-steps.yml configuration file when customizing the coding agent\u2019s development environment. To get started: Deploy ARC and configure a scale set. Update the runs-on: target in copilot-setup-steps.yml to the scale set. jobs: copilot-setup-steps: runs-on: arc-scale-set-name For additional guidance, refer to our documentation on customizing the development environment for GitHub Copilot coding agent. The post Copilot coding agent now supports self-hosted runners appeared first on The GitHub Blog.",
    "content_hash": "90d76f63fe08ba82d3430a6e2ca06f51e4c3f16f0f1d00de8fe627224616f7ed",
    "feed_index": 0,
    "detected_date": "2025-11-01T09:07:07.105895"
  }
]